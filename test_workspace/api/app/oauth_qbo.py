"""
QuickBooks Online OAuth Integration
Generated by IntegrationAgent
"""

from fastapi import APIRouter, HTTPException, Depends, status, Request
from fastapi.responses import RedirectResponse, JSONResponse
from fastapi.security import HTTPBearer
from typing import Dict, Optional
import requests
import logging
import os
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

# QuickBooks OAuth endpoints
QBO_AUTH_URL = "https://appcenter.intuit.com/connect/oauth2"
QBO_TOKEN_URL = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
QBO_REVOKE_URL = "https://developer.api.intuit.com/v2/oauth2/tokens/revoke"

QBO_CLIENT_ID = os.getenv("QBO_CLIENT_ID")
QBO_CLIENT_SECRET = os.getenv("QBO_CLIENT_SECRET")
QBO_REDIRECT_URI = os.getenv("QBO_REDIRECT_URI", "http://localhost:5000/auth/qbo/callback")
QBO_SCOPE = os.getenv("QBO_SCOPE", "com.intuit.quickbooks.accounting")


class QBOOAuth:
    """
    QuickBooks Online OAuth 2.0 handler
    """
    
    def __init__(self, db_session=None):
        self.client_id = QBO_CLIENT_ID
        self.client_secret = QBO_CLIENT_SECRET
        self.redirect_uri = QBO_REDIRECT_URI
        self.scope = QBO_SCOPE
        self.db_session = db_session
    
    def get_authorization_url(self, state: Optional[str] = None) -> str:
        """
        Generate QuickBooks OAuth authorization URL.
        
        Args:
            state: Optional state parameter for CSRF protection
            
        Returns:
            Authorization URL
        """
        params = {
            "client_id": self.client_id,
            "scope": self.scope,
            "redirect_uri": self.redirect_uri,
            "response_type": "code",
        }
        
        if state:
            params["state"] = state
        
        auth_url = f"{QBO_AUTH_URL}?{'&'.join(f'{k}={v}' for k, v in params.items())}"
        return auth_url
    
    def exchange_code_for_token(self, code: str, realm_id: str) -> Dict:
        """
        Exchange authorization code for access token.
        
        Args:
            code: Authorization code from callback
            realm_id: Company ID from QuickBooks
            
        Returns:
            Token response dictionary
        """
        data = {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": self.redirect_uri,
        }
        
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": f"Basic {self._get_basic_auth()}"
        }
        
        response = requests.post(QBO_TOKEN_URL, data=data, headers=headers)
        response.raise_for_status()
        
        token_data = response.json()
        
        # Store tokens in database
        if self.db_session:
            self._save_tokens(realm_id, token_data)
        
        return token_data
    
    def refresh_token(self, refresh_token: str, realm_id: str) -> Dict:
        """
        Refresh access token using refresh token.
        
        Args:
            refresh_token: Refresh token
            realm_id: Company ID
            
        Returns:
            Updated token data
        """
        data = {
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
        }
        
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": f"Basic {self._get_basic_auth()}"
        }
        
        response = requests.post(QBO_TOKEN_URL, data=data, headers=headers)
        response.raise_for_status()
        
        token_data = response.json()
        
        # Update tokens in database
        if self.db_session:
            self._update_tokens(realm_id, token_data)
        
        return token_data
    
    def _get_basic_auth(self) -> str:
        """Generate Basic Auth header for token requests."""
        import base64
        credentials = f"{self.client_id}:{self.client_secret}"
        return base64.b64encode(credentials.encode()).decode()
    
    def _save_tokens(self, realm_id: str, token_data: Dict):
        """Save tokens to database."""
        # Implementation depends on your database model
        # Example:
        # tenant = self.db_session.query(Tenant).filter_by(qbo_realm_id=realm_id).first()
        # if tenant:
        #     tenant.qbo_access_token = token_data.get("access_token")
        #     tenant.qbo_refresh_token = token_data.get("refresh_token")
        #     tenant.qbo_token_expires_at = datetime.now() + timedelta(seconds=token_data.get("expires_in", 3600))
        #     self.db_session.commit()
        pass
    
    def _update_tokens(self, realm_id: str, token_data: Dict):
        """Update tokens in database."""
        # Similar to _save_tokens
        pass


# FastAPI router
def create_qbo_auth_router(oauth_handler: QBOOAuth) -> APIRouter:
    """
    Create FastAPI router for QuickBooks OAuth routes.
    
    Args:
        oauth_handler: QBOOAuth instance
        
    Returns:
        FastAPI router with OAuth routes
    """
    router = APIRouter(prefix="/auth/qbo", tags=["qbo-oauth"])
    
    # Store state in memory (use Redis/DB in production)
    oauth_states: Dict[str, str] = {}
    
    @router.get("/authorize")
    async def qbo_authorize(state: Optional[str] = None) -> RedirectResponse:
        """Initiate QuickBooks OAuth flow."""
        if not state:
            state = os.urandom(16).hex()
        oauth_states[state] = state
        auth_url = oauth_handler.get_authorization_url(state=state)
        return RedirectResponse(url=auth_url)
    
    @router.get("/callback")
    async def qbo_callback(
        code: str,
        realmId: str,
        state: str
    ) -> JSONResponse:
        """Handle QuickBooks OAuth callback."""
        # Verify state
        if state not in oauth_states or oauth_states[state] != state:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid state parameter"
            )
        
        try:
            token_data = oauth_handler.exchange_code_for_token(code, realmId)
            del oauth_states[state]  # Clean up state
            return JSONResponse({
                "status": "success",
                "realm_id": realmId,
                "expires_in": token_data.get("expires_in")
            })
        except Exception as e:
            logger.error(f"Error in QBO OAuth callback: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    
    @router.post("/refresh")
    async def qbo_refresh(
        realm_id: str,
        refresh_token: str
    ) -> JSONResponse:
        """Refresh QuickBooks access token."""
        if not realm_id or not refresh_token:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing realm_id or refresh_token"
            )
        
        try:
            token_data = oauth_handler.refresh_token(refresh_token, realm_id)
            return JSONResponse({
                "status": "success",
                "expires_in": token_data.get("expires_in")
            })
        except Exception as e:
            logger.error(f"Error refreshing QBO token: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    
    return router

