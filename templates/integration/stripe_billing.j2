"""
Stripe Billing Integration
Generated by IntegrationAgent
"""

from fastapi import APIRouter, HTTPException, Depends, status, Request, Header
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import Dict, Optional
import stripe
import logging
import os
import json

logger = logging.getLogger(__name__)

# Stripe configuration
stripe.api_key = os.getenv("STRIPE_SECRET")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")
STRIPE_PLAN_MAP = json.loads(os.getenv("STRIPE_PLAN_MAP", '{"price_freebie": "Freebie", "price_starter": "Starter", "price_half": "Half", "price_full": "Full"}'))
BILLING_SUCCESS_URL = os.getenv("BILLING_SUCCESS_URL", "https://app.quick2odoo.online/billing/success")
BILLING_CANCEL_URL = os.getenv("BILLING_CANCEL_URL", "https://app.quick2odoo.online/billing/cancel")


class BillingManager:
    """
    Stripe billing manager
    """
    
    TIERS = {
        "Freebie": {"years": 2, "price_id": "price_freebie"},
        "Starter": {"years": 3, "price_id": "price_starter"},
        "Half": {"years": 5, "price_id": "price_half"},
        "Full": {"years": 10, "price_id": "price_full"},
    }
    
    def __init__(self, db_session=None):
        self.db_session = db_session
    
    def create_checkout_session(self, tenant_id: str, plan_name: str, customer_email: str = None) -> Dict:
        """
        Create Stripe checkout session.
        
        Args:
            tenant_id: Tenant ID
            plan_name: Plan name (Freebie, Starter, Half, Full)
            customer_email: Customer email
            
        Returns:
            Checkout session data
        """
        plan = self.TIERS.get(plan_name)
        if not plan:
            raise ValueError(f"Invalid plan: {plan_name}")
        
        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price": plan["price_id"],
                    "quantity": 1,
                }],
                mode="subscription",
                success_url=BILLING_SUCCESS_URL + f"?session_id={{CHECKOUT_SESSION_ID}}&tenant_id={tenant_id}",
                cancel_url=BILLING_CANCEL_URL,
                customer_email=customer_email,
                metadata={
                    "tenant_id": tenant_id,
                    "plan_name": plan_name
                }
            )
            
            return {
                "session_id": session.id,
                "url": session.url
            }
        except stripe.error.StripeError as e:
            logger.error(f"Stripe error: {str(e)}")
            raise
    
    def handle_webhook(self, payload: bytes, sig_header: str) -> Dict:
        """
        Handle Stripe webhook event.
        
        Args:
            payload: Webhook payload
            sig_header: Signature header
            
        Returns:
            Webhook event data
        """
        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, STRIPE_WEBHOOK_SECRET
            )
        except ValueError as e:
            logger.error(f"Invalid webhook payload: {str(e)}")
            raise
        except stripe.error.SignatureVerificationError as e:
            logger.error(f"Invalid webhook signature: {str(e)}")
            raise
        
        # Handle event
        if event["type"] == "checkout.session.completed":
            session = event["data"]["object"]
            tenant_id = session.get("metadata", {}).get("tenant_id")
            plan_name = session.get("metadata", {}).get("plan_name")
            
            # Update tenant plan in database
            if self.db_session and tenant_id:
                self._update_tenant_plan(tenant_id, plan_name)
        
        elif event["type"] == "customer.subscription.updated":
            subscription = event["data"]["object"]
            # Handle subscription update
            pass
        
        elif event["type"] == "customer.subscription.deleted":
            subscription = event["data"]["object"]
            # Handle subscription cancellation
            pass
        
        return {"status": "success"}
    
    def _update_tenant_plan(self, tenant_id: str, plan_name: str):
        """Update tenant plan in database."""
        # Implementation depends on your database model
        # Example:
        # tenant = self.db_session.query(Tenant).filter_by(id=tenant_id).first()
        # if tenant:
        #     tenant.plan = plan_name
        #     self.db_session.commit()
        pass


# FastAPI router
def create_billing_router(billing_manager: BillingManager) -> APIRouter:
    """
    Create FastAPI router for billing routes.
    
    Args:
        billing_manager: BillingManager instance
        
    Returns:
        FastAPI router with billing routes
    """
    router = APIRouter(prefix="/api/billing", tags=["billing"])
    
    class CheckoutRequest(BaseModel):
        tenant_id: str
        plan_name: str
        customer_email: Optional[str] = None
    
    @router.post("/checkout", status_code=status.HTTP_201_CREATED)
    async def create_checkout(request: CheckoutRequest) -> JSONResponse:
        """Create Stripe checkout session."""
        if not request.tenant_id or not request.plan_name:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing tenant_id or plan_name"
            )
        
        try:
            session_data = billing_manager.create_checkout_session(
                request.tenant_id, request.plan_name, request.customer_email
            )
            return JSONResponse(session_data)
        except Exception as e:
            logger.error(f"Error creating checkout: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    
    @router.post("/webhook", status_code=status.HTTP_200_OK)
    async def stripe_webhook(
        request: Request,
        stripe_signature: str = Header(..., alias="Stripe-Signature")
    ) -> JSONResponse:
        """Handle Stripe webhook."""
        payload = await request.body()
        
        try:
            result = billing_manager.handle_webhook(payload, stripe_signature)
            return JSONResponse(result)
        except Exception as e:
            logger.error(f"Error handling webhook: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
    
    return router

