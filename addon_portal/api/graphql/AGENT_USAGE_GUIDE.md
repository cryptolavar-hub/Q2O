# How Q2O Agents Use GraphQL

## Coder Agent: Generating GraphQL APIs for Client Projects

### Use Case
When a client requests: "Build a project management system with flexible API"

The Coder Agent can now generate **both REST and GraphQL** endpoints:
- **REST**: For simple CRUD operations
- **GraphQL**: For complex queries, real-time updates, mobile apps

---

## ðŸŽ¯ Template: Coder Agent GraphQL Generation

### agents/templates/graphql_api_template.py.jinja2

```python
"""
GraphQL API for {{ project_name }}
Auto-generated by Q2O Coder Agent

Client can query exactly what they need, reducing bandwidth.
"""
import strawberry
from typing import List, Optional
from datetime import datetime

# ============================================================================
# TYPES
# ============================================================================

@strawberry.type
class {{ entity_name }}:
    """{{ entity_description }}"""
    {% for field in fields %}
    {{ field.name }}: {{ field.type }}
    {% endfor %}
    
    {% if computed_fields %}
    # Computed fields
    {% for computed in computed_fields %}
    @strawberry.field
    def {{ computed.name }}(self) -> {{ computed.type }}:
        """{{ computed.description }}"""
        {{ computed.logic }}
    {% endfor %}
    {% endif %}

# ============================================================================
# QUERIES
# ============================================================================

@strawberry.type
class Query:
    """Root Query - Read operations"""
    
    @strawberry.field
    async def {{ entity_name_plural }}(
        self,
        info,
        limit: int = 50,
        offset: int = 0
    ) -> List[{{ entity_name }}]:
        """
        Get all {{ entity_name_plural }}
        
        Example:
        query {
          {{ entity_name_plural }}(limit: 10) {
            {% for field in fields[:3] %}
            {{ field.name }}
            {% endfor %}
          }
        }
        """
        db = info.context["db"]
        # Query implementation
        ...

# ============================================================================
# MUTATIONS
# ============================================================================

@strawberry.type
class Mutation:
    """Root Mutation - Write operations"""
    
    @strawberry.mutation
    async def create_{{ entity_name_lower }}(
        self,
        info,
        input: {{ entity_name }}Input
    ) -> {{ entity_name }}:
        """Create new {{ entity_name_lower }}"""
        db = info.context["db"]
        # Create implementation
        ...

# ============================================================================
# SUBSCRIPTIONS (Real-time)
# ============================================================================

@strawberry.type
class Subscription:
    """Real-time subscriptions"""
    
    @strawberry.subscription
    async def {{ entity_name_lower }}_created(
        self,
        info
    ) -> AsyncGenerator[{{ entity_name }}, None]:
        """Subscribe to new {{ entity_name_plural }}"""
        # Real-time implementation
        ...
```

---

## ðŸŽ¨ Example: Coder Agent Generates Task Management API

### Client Request:
> "Build a task management system where users can create, assign, and track tasks in real-time"

### Coder Agent Output:

```python
# Generated: task_api_graphql.py

import strawberry
from typing import List, Optional
from datetime import datetime
from enum import Enum

@strawberry.enum
class TaskStatus(Enum):
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    DONE = "done"

@strawberry.type
class Task:
    id: str
    title: str
    description: Optional[str]
    status: TaskStatus
    assigned_to: Optional[str]
    created_at: datetime
    due_date: Optional[datetime]
    
    @strawberry.field
    def is_overdue(self) -> bool:
        """Check if task is overdue"""
        if self.due_date and self.status != TaskStatus.DONE:
            return datetime.utcnow() > self.due_date
        return False

@strawberry.type
class Query:
    @strawberry.field
    async def tasks(
        self,
        info,
        status: Optional[TaskStatus] = None,
        assigned_to: Optional[str] = None,
        limit: int = 50
    ) -> List[Task]:
        """
        Get tasks with flexible filtering
        
        Example:
        query {
          tasks(status: IN_PROGRESS, assignedTo: "user-123") {
            title
            dueDate
            isOverdue
          }
        }
        """
        db = info.context["db"]
        query = select(Task)
        if status:
            query = query.where(Task.status == status)
        if assigned_to:
            query = query.where(Task.assigned_to == assigned_to)
        result = await db.execute(query.limit(limit))
        return result.scalars().all()

@strawberry.type
class Mutation:
    @strawberry.mutation
    async def create_task(
        self,
        info,
        title: str,
        description: Optional[str] = None,
        assigned_to: Optional[str] = None
    ) -> Task:
        """
        Create a new task
        
        Example:
        mutation {
          createTask(
            title: "Fix login bug"
            assignedTo: "user-123"
          ) {
            id
            title
            status
          }
        }
        """
        db = info.context["db"]
        new_task = Task(
            id=uuid4().hex,
            title=title,
            description=description,
            status=TaskStatus.TODO,
            assigned_to=assigned_to,
            created_at=datetime.utcnow()
        )
        db.add(new_task)
        await db.commit()
        return new_task

@strawberry.type
class Subscription:
    @strawberry.subscription
    async def task_created(self, info) -> AsyncGenerator[Task, None]:
        """
        Subscribe to new tasks in real-time
        
        Example (JavaScript):
        subscription {
          taskCreated {
            id
            title
            assignedTo
          }
        }
        """
        async for event in task_event_queue:
            if event["type"] == "created":
                yield event["task"]

# Build schema
schema = strawberry.Schema(
    query=Query,
    mutation=Mutation,
    subscription=Subscription
)
```

---

## ðŸ“± Mobile App Benefits

### Scenario: Mobile App on 3G Connection

**Without GraphQL (REST)**:
```typescript
// Mobile app needs task list - fetches EVERYTHING
const response = await fetch('/api/tasks');
const tasks = await response.json();

// Response: 250 KB
// {
//   tasks: [
//     {
//       id: "1",
//       title: "Fix bug",
//       description: "Long description...",  // Don't need!
//       created_at: "...",
//       updated_at: "...",
//       metadata: {...},  // Don't need!
//       assignee: {  // Don't need full object!
//         id: "123",
//         name: "John",
//         email: "...",
//         avatar: "..."
//       }
//     },
//     // ... 99 more tasks
//   ]
// }
```

**With GraphQL**:
```typescript
// Mobile app requests ONLY what it needs
const { data } = await apolloClient.query({
  query: gql`
    query {
      tasks(limit: 100) {
        title
        status
        isOverdue
      }
    }
  `
});

// Response: 8 KB (97% bandwidth reduction!)
// {
//   tasks: [
//     {
//       title: "Fix bug",
//       status: "IN_PROGRESS",
//       isOverdue: false
//     },
//     // ... 99 more tasks (only 3 fields each)
//   ]
// }
```

---

## ðŸ—ï¸ Coder Agent Configuration

### config.json Enhancement

```json
{
  "project_name": "TaskManagementApp",
  "objective": "Build task management with real-time updates",
  "api_type": "hybrid",  // ðŸ†• NEW: "rest" | "graphql" | "hybrid"
  "features": [
    "crud_operations",
    "real_time_updates",  // Triggers GraphQL subscriptions
    "mobile_app",  // Triggers GraphQL for bandwidth optimization
    "flexible_querying"  // Triggers GraphQL for complex filters
  ],
  "graphql_config": {
    "enable_subscriptions": true,
    "enable_playground": true,
    "rate_limit": "100/minute"
  }
}
```

### Coder Agent Logic

```python
# agents/coder_agent.py

class CoderAgent(BaseAgent):
    def should_generate_graphql(self, config: dict) -> bool:
        """
        Determine if project needs GraphQL
        
        Triggers:
        - Mobile app (bandwidth optimization)
        - Real-time updates (subscriptions)
        - Complex querying (flexibility)
        - Public API (customer-facing)
        """
        features = config.get("features", [])
        
        return any([
            "mobile_app" in features,
            "real_time_updates" in features,
            "flexible_querying" in features,
            "public_api" in features,
            config.get("api_type") in ["graphql", "hybrid"]
        ])
    
    async def generate_api(self, config: dict):
        """Generate API based on requirements"""
        
        # Always generate REST (simple CRUD)
        await self.generate_rest_api(config)
        
        # Generate GraphQL if needed
        if self.should_generate_graphql(config):
            await self.generate_graphql_api(config)
            await self.generate_apollo_client_setup(config)
            logger.info("âœ… Generated hybrid REST + GraphQL API")
        else:
            logger.info("âœ… Generated REST API only")
```

---

## ðŸŽ¯ When Coder Agent Chooses GraphQL

| Client Request | API Type | Reason |
|----------------|----------|--------|
| "Build admin dashboard" | **REST** | Internal use, simple CRUD |
| "Build mobile app" | **GraphQL** | Bandwidth optimization |
| "Real-time notifications" | **GraphQL** | Subscriptions support |
| "Public API for customers" | **Hybrid** | Flexibility for 3rd parties |
| "Complex filtering/search" | **GraphQL** | Flexible querying |
| "Simple CRUD API" | **REST** | Simplicity, caching |

---

## ðŸš€ Deployment: Coder Agent Generated Project

### Generated Project Structure

```
generated_project/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ rest/          # REST endpoints (simple CRUD)
â”‚   â”‚   â”‚   â”œâ”€â”€ tasks.py
â”‚   â”‚   â”‚   â””â”€â”€ users.py
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ graphql/       # GraphQL API (advanced features)
â”‚   â”‚       â”œâ”€â”€ schema.py
â”‚   â”‚       â”œâ”€â”€ types.py
â”‚   â”‚       â”œâ”€â”€ resolvers.py
â”‚   â”‚       â””â”€â”€ dataloaders.py
â”‚   â”‚
â”‚   â””â”€â”€ main.py            # FastAPI app with both REST + GraphQL
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ apollo-client.ts   # GraphQL client setup
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard.tsx  # Uses GraphQL queries
â”‚   â”‚   â”‚   â””â”€â”€ tasks.tsx      # Uses GraphQL subscriptions
â”‚   â”‚   â””â”€â”€ hooks/
â”‚   â”‚       â””â”€â”€ useRealtimeTasks.ts  # Custom hook with subscription
â”‚   â”‚
â”‚   â””â”€â”€ package.json       # Includes @apollo/client
â”‚
â””â”€â”€ README.md              # Generated by Q2O with usage examples
```

---

## ðŸ“– Documentation Generated by Coder Agent

The Coder Agent automatically generates:

1. **API Reference** - All queries, mutations, subscriptions
2. **Example Queries** - Copy-paste examples for common use cases
3. **Client Setup Guide** - How to configure Apollo Client
4. **Testing Guide** - How to test GraphQL endpoints
5. **Deployment Guide** - Production configuration

---

## ðŸ’¡ Key Takeaways

âœ… **Coder Agent can generate both REST and GraphQL**
âœ… **Automatically chooses based on project requirements**
âœ… **Mobile apps always get GraphQL (bandwidth optimization)**
âœ… **Real-time features use GraphQL subscriptions**
âœ… **Public APIs get hybrid (flexibility for customers)**
âœ… **Simple internal tools stick with REST (simplicity)**

This makes Q2O the **most flexible code generation platform** - clients get the **right API architecture** for their specific needs automatically! ðŸš€

