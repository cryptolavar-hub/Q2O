"""
Integration Agent - Handles external API integrations.
Generates code for QuickBooks, Odoo, Stripe integrations with OAuth, webhooks, and API clients.
"""

from typing import Dict, Any, List
from agents.base_agent import BaseAgent, AgentType, Task, TaskStatus
import os
import logging


class IntegrationAgent(BaseAgent):
    """Agent responsible for external API integrations."""

    def __init__(self, agent_id: str = "integration_main", workspace_path: str = "."):
        super().__init__(agent_id, AgentType.INTEGRATION)
        self.workspace_path = workspace_path
        self.integration_files: List[str] = []

    def process_task(self, task: Task) -> Task:
        """
        Process an integration task by generating integration code.
        
        Args:
            task: The integration task to process
            
        Returns:
            The updated task
        """
        try:
            self.logger.info(f"Processing integration task: {task.title}")
            
            # Extract task information
            description = task.description.lower()
            metadata = task.metadata
            integration_type = metadata.get("integration_type", self._detect_integration_type(description))
            
            # Generate integration code
            files_created = []
            
            if "quickbooks" in description or "qbo" in description:
                files_created.extend(self._create_quickbooks_integration(task))
            
            if "odoo" in description:
                files_created.extend(self._create_odoo_integration(task))
            
            if "stripe" in description or "billing" in description:
                files_created.extend(self._create_stripe_integration(task))
            
            # Update task metadata
            task.metadata["integration_files"] = files_created
            task.metadata["integration_type"] = integration_type
            task.result = {
                "files_created": files_created,
                "integration_type": integration_type,
                "status": "completed"
            }

            self.complete_task(task.id, task.result)
            self.logger.info(f"Completed integration task {task.id}")
            
        except Exception as e:
            error_msg = f"Error processing integration task: {str(e)}"
            self.logger.error(error_msg, exc_info=True)
            self.fail_task(task.id, error_msg)
            
        return task

    def _detect_integration_type(self, description: str) -> str:
        """Detect integration type from description."""
        if "quickbooks" in description or "qbo" in description:
            return "quickbooks"
        elif "odoo" in description:
            return "odoo"
        elif "stripe" in description:
            return "stripe"
        elif "oauth" in description:
            return "oauth"
        elif "webhook" in description:
            return "webhook"
        return "generic"

    def _create_quickbooks_integration(self, task: Task) -> List[str]:
        """Create QuickBooks integration code."""
        files_created = []
        description = task.description.lower()
        
        if "oauth" in description or "auth" in description:
            files_created.append(self._create_qbo_oauth(task))
        
        if "client" in description or "api" in description:
            files_created.append(self._create_qbo_client(task))
        
        if "webconnector" in description or "qbd" in description or "desktop" in description:
            files_created.append(self._create_qbd_webconnector(task))
        
        return files_created

    def _create_qbo_oauth(self, task: Task) -> str:
        """Create QuickBooks OAuth implementation."""
        file_path = "api/app/oauth_qbo.py"
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        content = '''"""
QuickBooks Online OAuth Integration
Generated by IntegrationAgent
"""

from fastapi import APIRouter, HTTPException, Depends, status, Request
from fastapi.responses import RedirectResponse, JSONResponse
from fastapi.security import HTTPBearer
from typing import Dict, Optional
import requests
import logging
import os
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

# QuickBooks OAuth endpoints
QBO_AUTH_URL = "https://appcenter.intuit.com/connect/oauth2"
QBO_TOKEN_URL = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
QBO_REVOKE_URL = "https://developer.api.intuit.com/v2/oauth2/tokens/revoke"

QBO_CLIENT_ID = os.getenv("QBO_CLIENT_ID")
QBO_CLIENT_SECRET = os.getenv("QBO_CLIENT_SECRET")
QBO_REDIRECT_URI = os.getenv("QBO_REDIRECT_URI", "http://localhost:5000/auth/qbo/callback")
QBO_SCOPE = os.getenv("QBO_SCOPE", "com.intuit.quickbooks.accounting")


class QBOOAuth:
    """
    QuickBooks Online OAuth 2.0 handler
    """
    
    def __init__(self, db_session=None):
        self.client_id = QBO_CLIENT_ID
        self.client_secret = QBO_CLIENT_SECRET
        self.redirect_uri = QBO_REDIRECT_URI
        self.scope = QBO_SCOPE
        self.db_session = db_session
    
    def get_authorization_url(self, state: Optional[str] = None) -> str:
        """
        Generate QuickBooks OAuth authorization URL.
        
        Args:
            state: Optional state parameter for CSRF protection
            
        Returns:
            Authorization URL
        """
        params = {
            "client_id": self.client_id,
            "scope": self.scope,
            "redirect_uri": self.redirect_uri,
            "response_type": "code",
        }
        
        if state:
            params["state"] = state
        
        auth_url = f"{QBO_AUTH_URL}?{'&'.join(f'{k}={v}' for k, v in params.items())}"
        return auth_url
    
    def exchange_code_for_token(self, code: str, realm_id: str) -> Dict:
        """
        Exchange authorization code for access token.
        
        Args:
            code: Authorization code from callback
            realm_id: Company ID from QuickBooks
            
        Returns:
            Token response dictionary
        """
        data = {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": self.redirect_uri,
        }
        
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": f"Basic {self._get_basic_auth()}"
        }
        
        response = requests.post(QBO_TOKEN_URL, data=data, headers=headers)
        response.raise_for_status()
        
        token_data = response.json()
        
        # Store tokens in database
        if self.db_session:
            self._save_tokens(realm_id, token_data)
        
        return token_data
    
    def refresh_token(self, refresh_token: str, realm_id: str) -> Dict:
        """
        Refresh access token using refresh token.
        
        Args:
            refresh_token: Refresh token
            realm_id: Company ID
            
        Returns:
            Updated token data
        """
        data = {
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
        }
        
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": f"Basic {self._get_basic_auth()}"
        }
        
        response = requests.post(QBO_TOKEN_URL, data=data, headers=headers)
        response.raise_for_status()
        
        token_data = response.json()
        
        # Update tokens in database
        if self.db_session:
            self._update_tokens(realm_id, token_data)
        
        return token_data
    
    def _get_basic_auth(self) -> str:
        """Generate Basic Auth header for token requests."""
        import base64
        credentials = f"{self.client_id}:{self.client_secret}"
        return base64.b64encode(credentials.encode()).decode()
    
    def _save_tokens(self, realm_id: str, token_data: Dict):
        """Save tokens to database."""
        # Implementation depends on your database model
        # Example:
        # tenant = self.db_session.query(Tenant).filter_by(qbo_realm_id=realm_id).first()
        # if tenant:
        #     tenant.qbo_access_token = token_data.get("access_token")
        #     tenant.qbo_refresh_token = token_data.get("refresh_token")
        #     tenant.qbo_token_expires_at = datetime.now() + timedelta(seconds=token_data.get("expires_in", 3600))
        #     self.db_session.commit()
        pass
    
    def _update_tokens(self, realm_id: str, token_data: Dict):
        """Update tokens in database."""
        # Similar to _save_tokens
        pass


# FastAPI router
def create_qbo_auth_router(oauth_handler: QBOOAuth) -> APIRouter:
    """
    Create FastAPI router for QuickBooks OAuth routes.
    
    Args:
        oauth_handler: QBOOAuth instance
        
    Returns:
        FastAPI router with OAuth routes
    """
    router = APIRouter(prefix="/auth/qbo", tags=["qbo-oauth"])
    
    # Store state in memory (use Redis/DB in production)
    oauth_states: Dict[str, str] = {}
    
    @router.get("/authorize")
    async def qbo_authorize(state: Optional[str] = None) -> RedirectResponse:
        """Initiate QuickBooks OAuth flow."""
        if not state:
            state = os.urandom(16).hex()
        oauth_states[state] = state
        auth_url = oauth_handler.get_authorization_url(state=state)
        return RedirectResponse(url=auth_url)
    
    @router.get("/callback")
    async def qbo_callback(
        code: str,
        realmId: str,
        state: str
    ) -> JSONResponse:
        """Handle QuickBooks OAuth callback."""
        # Verify state
        if state not in oauth_states or oauth_states[state] != state:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid state parameter"
            )
        
        try:
            token_data = oauth_handler.exchange_code_for_token(code, realmId)
            del oauth_states[state]  # Clean up state
            return JSONResponse({
                "status": "success",
                "realm_id": realmId,
                "expires_in": token_data.get("expires_in")
            })
        except Exception as e:
            logger.error(f"Error in QBO OAuth callback: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    
    @router.post("/refresh")
    async def qbo_refresh(
        realm_id: str,
        refresh_token: str
    ) -> JSONResponse:
        """Refresh QuickBooks access token."""
        if not realm_id or not refresh_token:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing realm_id or refresh_token"
            )
        
        try:
            token_data = oauth_handler.refresh_token(refresh_token, realm_id)
            return JSONResponse({
                "status": "success",
                "expires_in": token_data.get("expires_in")
            })
        except Exception as e:
            logger.error(f"Error refreshing QBO token: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    
    return router
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.integration_files.append(file_path)
        return file_path

    def _create_qbo_client(self, task: Task) -> str:
        """Create QuickBooks API client."""
        file_path = "api/app/clients/qbo.py"
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        content = '''"""
QuickBooks Online API Client
Generated by IntegrationAgent
"""

import requests
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

QBO_API_BASE = "https://sandbox-quickbooks.api.intuit.com/v3"  # Use production URL for live


class QBOClient:
    """
    QuickBooks Online API client
    """
    
    def __init__(self, realm_id: str, access_token: str):
        """
        Initialize QBO client.
        
        Args:
            realm_id: QuickBooks company ID
            access_token: OAuth access token
        """
        self.realm_id = realm_id
        self.access_token = access_token
        self.base_url = QBO_API_BASE
        self.headers = {
            "Authorization": f"Bearer {self.access_token}",
            "Accept": "application/json",
            "Content-Type": "application/json"
        }
    
    def _make_request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Dict:
        """
        Make API request to QuickBooks.
        
        Args:
            method: HTTP method
            endpoint: API endpoint
            data: Request body data
            
        Returns:
            Response JSON
        """
        url = f"{self.base_url}/company/{self.realm_id}/{endpoint}"
        
        response = requests.request(
            method=method,
            url=url,
            headers=self.headers,
            json=data
        )
        
        response.raise_for_status()
        return response.json()
    
    def get_company_info(self) -> Dict:
        """Get company information."""
        return self._make_request("GET", "companyinfo")
    
    def query(self, query: str) -> List[Dict]:
        """
        Execute QuickBooks query.
        
        Args:
            query: QuickBooks query string (SQL-like)
            
        Returns:
            List of entities
        """
        response = self._make_request("GET", f"query?query={query}")
        return response.get("QueryResponse", {}).get("entities", [])
    
    def get_customers(self) -> List[Dict]:
        """Get all customers."""
        return self.query("SELECT * FROM Customer")
    
    def get_items(self) -> List[Dict]:
        """Get all items."""
        return self.query("SELECT * FROM Item")
    
    def get_invoices(self, start_date: Optional[str] = None) -> List[Dict]:
        """Get invoices, optionally filtered by start date."""
        query = "SELECT * FROM Invoice"
        if start_date:
            query += f" WHERE MetaData.LastUpdatedTime > '{start_date}'"
        return self.query(query)
    
    def create_invoice(self, invoice_data: Dict) -> Dict:
        """Create an invoice."""
        response = self._make_request("POST", "invoice", {"Invoice": invoice_data})
        return response.get("Invoice", {})
    
    def update_entity(self, entity_type: str, entity_id: str, sync_token: str, data: Dict) -> Dict:
        """
        Update an entity.
        
        Args:
            entity_type: Entity type (e.g., "Customer", "Invoice")
            entity_id: Entity ID
            sync_token: Sync token from previous read
            data: Updated entity data
            
        Returns:
            Updated entity
        """
        endpoint = entity_type.lower()
        data["Id"] = entity_id
        data["SyncToken"] = sync_token
        response = self._make_request("POST", endpoint, {entity_type: data})
        return response.get(entity_type, {})
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.integration_files.append(file_path)
        return file_path

    def _create_odoo_integration(self, task: Task) -> List[str]:
        """Create Odoo integration code."""
        files_created = []
        
        files_created.append(self._create_odoo_client(task))
        
        return files_created

    def _create_odoo_client(self, task: Task) -> str:
        """Create Odoo JSON-RPC client."""
        file_path = "api/app/clients/odoo.py"
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        content = '''"""
Odoo v18 JSON-RPC Client
Generated by IntegrationAgent
"""

import requests
from typing import Dict, List, Optional, Any
import logging

logger = logging.getLogger(__name__)


class OdooClient:
    """
    Odoo v18 JSON-RPC API client
    """
    
    def __init__(self, base_url: str, database: str, username: str, api_key: str):
        """
        Initialize Odoo client.
        
        Args:
            base_url: Odoo instance URL (e.g., https://odoo.example.com)
            database: Database name
            username: Odoo username
            api_key: API key or password
        """
        self.base_url = base_url.rstrip("/")
        self.database = database
        self.username = username
        self.api_key = api_key
        self.uid = None
        self.session = requests.Session()
        
        # Authenticate
        self._authenticate()
    
    def _authenticate(self):
        """Authenticate and get user ID."""
        try:
            response = self._call("common", "authenticate", [
                self.database,
                self.username,
                self.api_key,
                {}
            ])
            self.uid = response
        except Exception as e:
            logger.error(f"Failed to authenticate with Odoo: {str(e)}")
            raise
    
    def _call(self, service: str, method: str, params: List) -> Any:
        """
        Make JSON-RPC call to Odoo.
        
        Args:
            service: RPC service (common, object, etc.)
            method: RPC method
            params: Method parameters
            
        Returns:
            Response data
        """
        url = f"{self.base_url}/jsonrpc"
        
        payload = {
            "jsonrpc": "2.0",
            "method": "call",
            "params": {
                "service": service,
                "method": method,
                "args": params
            },
            "id": 1
        }
        
        response = self.session.post(url, json=payload)
        response.raise_for_status()
        
        result = response.json()
        if "error" in result:
            raise Exception(f"Odoo RPC error: {result['error']}")
        
        return result.get("result")
    
    def search_read(self, model: str, domain: List, fields: List[str], 
                   offset: int = 0, limit: int = None) -> List[Dict]:
        """
        Search and read records.
        
        Args:
            model: Odoo model name (e.g., "res.partner")
            domain: Search domain
            fields: Fields to return
            offset: Offset for pagination
            limit: Limit for pagination
            
        Returns:
            List of records
        """
        params = [self.database, self.uid, self.api_key, model, "search_read", domain, fields]
        
        if limit:
            params.extend([offset, limit])
        
        return self._call("object", "execute_kw", params)
    
    def create(self, model: str, values: Dict) -> int:
        """
        Create a new record.
        
        Args:
            model: Odoo model name
            values: Field values
            
        Returns:
            Created record ID
        """
        params = [self.database, self.uid, self.api_key, model, "create", [values]]
        return self._call("object", "execute_kw", params)
    
    def write(self, model: str, record_id: int, values: Dict) -> bool:
        """
        Update a record.
        
        Args:
            model: Odoo model name
            record_id: Record ID
            values: Updated field values
            
        Returns:
            True if successful
        """
        params = [self.database, self.uid, self.api_key, model, "write", [[record_id], values]]
        return self._call("object", "execute_kw", params)
    
    def unlink(self, model: str, record_ids: List[int]) -> bool:
        """
        Delete records.
        
        Args:
            model: Odoo model name
            record_ids: List of record IDs to delete
            
        Returns:
            True if successful
        """
        params = [self.database, self.uid, self.api_key, model, "unlink", [record_ids]]
        return self._call("object", "execute_kw", params)
    
    def call_method(self, model: str, method_name: str, record_ids: List[int], *args) -> Any:
        """
        Call a custom method on records.
        
        Args:
            model: Odoo model name
            method_name: Method name
            record_ids: Record IDs
            *args: Additional arguments
            
        Returns:
            Method result
        """
        params = [self.database, self.uid, self.api_key, model, method_name, record_ids]
        params.extend(args)
        return self._call("object", "execute_kw", params)
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.integration_files.append(file_path)
        return file_path

    def _create_stripe_integration(self, task: Task) -> List[str]:
        """Create Stripe integration code."""
        files_created = []
        
        files_created.append(self._create_stripe_billing(task))
        
        return files_created

    def _create_stripe_billing(self, task: Task) -> str:
        """Create Stripe billing integration."""
        file_path = "api/app/billing.py"
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        content = '''"""
Stripe Billing Integration
Generated by IntegrationAgent
"""

from fastapi import APIRouter, HTTPException, Depends, status, Request, Header
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import Dict, Optional
import stripe
import logging
import os
import json

logger = logging.getLogger(__name__)

# Stripe configuration
stripe.api_key = os.getenv("STRIPE_SECRET")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")
STRIPE_PLAN_MAP = json.loads(os.getenv("STRIPE_PLAN_MAP", '{"price_freebie": "Freebie", "price_starter": "Starter", "price_half": "Half", "price_full": "Full"}'))
BILLING_SUCCESS_URL = os.getenv("BILLING_SUCCESS_URL", "https://app.quick2odoo.online/billing/success")
BILLING_CANCEL_URL = os.getenv("BILLING_CANCEL_URL", "https://app.quick2odoo.online/billing/cancel")


class BillingManager:
    """
    Stripe billing manager
    """
    
    TIERS = {
        "Freebie": {"years": 2, "price_id": "price_freebie"},
        "Starter": {"years": 3, "price_id": "price_starter"},
        "Half": {"years": 5, "price_id": "price_half"},
        "Full": {"years": 10, "price_id": "price_full"},
    }
    
    def __init__(self, db_session=None):
        self.db_session = db_session
    
    def create_checkout_session(self, tenant_id: str, plan_name: str, customer_email: str = None) -> Dict:
        """
        Create Stripe checkout session.
        
        Args:
            tenant_id: Tenant ID
            plan_name: Plan name (Freebie, Starter, Half, Full)
            customer_email: Customer email
            
        Returns:
            Checkout session data
        """
        plan = self.TIERS.get(plan_name)
        if not plan:
            raise ValueError(f"Invalid plan: {plan_name}")
        
        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price": plan["price_id"],
                    "quantity": 1,
                }],
                mode="subscription",
                success_url=BILLING_SUCCESS_URL + f"?session_id={{CHECKOUT_SESSION_ID}}&tenant_id={tenant_id}",
                cancel_url=BILLING_CANCEL_URL,
                customer_email=customer_email,
                metadata={
                    "tenant_id": tenant_id,
                    "plan_name": plan_name
                }
            )
            
            return {
                "session_id": session.id,
                "url": session.url
            }
        except stripe.error.StripeError as e:
            logger.error(f"Stripe error: {str(e)}")
            raise
    
    def handle_webhook(self, payload: bytes, sig_header: str) -> Dict:
        """
        Handle Stripe webhook event.
        
        Args:
            payload: Webhook payload
            sig_header: Signature header
            
        Returns:
            Webhook event data
        """
        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, STRIPE_WEBHOOK_SECRET
            )
        except ValueError as e:
            logger.error(f"Invalid webhook payload: {str(e)}")
            raise
        except stripe.error.SignatureVerificationError as e:
            logger.error(f"Invalid webhook signature: {str(e)}")
            raise
        
        # Handle event
        if event["type"] == "checkout.session.completed":
            session = event["data"]["object"]
            tenant_id = session.get("metadata", {}).get("tenant_id")
            plan_name = session.get("metadata", {}).get("plan_name")
            
            # Update tenant plan in database
            if self.db_session and tenant_id:
                self._update_tenant_plan(tenant_id, plan_name)
        
        elif event["type"] == "customer.subscription.updated":
            subscription = event["data"]["object"]
            # Handle subscription update
            pass
        
        elif event["type"] == "customer.subscription.deleted":
            subscription = event["data"]["object"]
            # Handle subscription cancellation
            pass
        
        return {"status": "success"}
    
    def _update_tenant_plan(self, tenant_id: str, plan_name: str):
        """Update tenant plan in database."""
        # Implementation depends on your database model
        # Example:
        # tenant = self.db_session.query(Tenant).filter_by(id=tenant_id).first()
        # if tenant:
        #     tenant.plan = plan_name
        #     self.db_session.commit()
        pass


# FastAPI router
def create_billing_router(billing_manager: BillingManager) -> APIRouter:
    """
    Create FastAPI router for billing routes.
    
    Args:
        billing_manager: BillingManager instance
        
    Returns:
        FastAPI router with billing routes
    """
    router = APIRouter(prefix="/api/billing", tags=["billing"])
    
    class CheckoutRequest(BaseModel):
        tenant_id: str
        plan_name: str
        customer_email: Optional[str] = None
    
    @router.post("/checkout", status_code=status.HTTP_201_CREATED)
    async def create_checkout(request: CheckoutRequest) -> JSONResponse:
        """Create Stripe checkout session."""
        if not request.tenant_id or not request.plan_name:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing tenant_id or plan_name"
            )
        
        try:
            session_data = billing_manager.create_checkout_session(
                request.tenant_id, request.plan_name, request.customer_email
            )
            return JSONResponse(session_data)
        except Exception as e:
            logger.error(f"Error creating checkout: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    
    @router.post("/webhook", status_code=status.HTTP_200_OK)
    async def stripe_webhook(
        request: Request,
        stripe_signature: str = Header(..., alias="Stripe-Signature")
    ) -> JSONResponse:
        """Handle Stripe webhook."""
        payload = await request.body()
        
        try:
            result = billing_manager.handle_webhook(payload, stripe_signature)
            return JSONResponse(result)
        except Exception as e:
            logger.error(f"Error handling webhook: {str(e)}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
    
    return router
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.integration_files.append(file_path)
        return file_path

    def _create_qbd_webconnector(self, task: Task) -> str:
        """Create QuickBooks Desktop web connector generator."""
        file_path = "api/app/qbd.py"
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        content = '''"""
QuickBooks Desktop Web Connector
Generated by IntegrationAgent
"""

from fastapi import APIRouter, HTTPException, Query, status
from fastapi.responses import Response
from typing import Dict, Optional
import xml.etree.ElementTree as ET
import logging

logger = logging.getLogger(__name__)


def generate_qwc_file(company: str, app_url: str) -> str:
    """
    Generate QuickBooks Web Connector .qwc file.
    
    Args:
        company: Company name
        app_url: Application URL
        
    Returns:
        QWC XML content
    """
    root = ET.Element("QBWCXML")
    
    app_name = ET.SubElement(root, "AppName")
    app_name.text = "Quick2Odoo Desktop"
    
    app_id = ET.SubElement(root, "AppID")
    app_id.text = ""
    
    app_url_elem = ET.SubElement(root, "AppURL")
    app_url_elem.text = app_url
    
    app_support = ET.SubElement(root, "AppSupport")
    app_support.text = "https://quick2odoo.online/support"
    
    user_name = ET.SubElement(root, "UserName")
    user_name.text = ""
    
    owner_id = ET.SubElement(root, "OwnerID")
    owner_id.text = ""
    
    file_id = ET.SubElement(root, "FileID")
    file_id.text = ""
    
    qb_type = ET.SubElement(root, "QBType")
    qb_type.text = "QBFS"
    
    is_read_only = ET.SubElement(root, "IsReadOnly")
    is_read_only.text = "false"
    
    ET.indent(root)
    return ET.tostring(root, encoding="unicode", xml_declaration=True)


# FastAPI router
def create_qbd_router() -> APIRouter:
    """
    Create FastAPI router for QBD routes.
    
    Returns:
        FastAPI router with QBD routes
    """
    router = APIRouter(prefix="/qbd", tags=["qbd"])
    
    @router.get("/webconnector.qwc")
    async def get_webconnector(
        company: str = Query("Default Company", description="Company name"),
        appurl: str = Query(..., description="Application URL")
    ) -> Response:
        """Generate and return .qwc file."""
        qwc_content = generate_qwc_file(company, appurl)
        
        return Response(
            content=qwc_content,
            media_type="application/x-qwc",
            headers={
                "Content-Disposition": "attachment; filename=quick2odoo.qwc"
            }
        )
    
    @router.post("/ping")
    async def qbd_ping() -> Response:
        """Handle QBD ping request."""
        # QuickBooks Desktop Web Connector ping handler
        # Placeholder for CDC/SOAP loop
        return Response(
            content="""<?xml version="1.0"?>
<QBWCXML>
    <ServerVersion>1.0</ServerVersion>
</QBWCXML>""",
            media_type="application/xml"
        )
    
    return router
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.integration_files.append(file_path)
        return file_path

