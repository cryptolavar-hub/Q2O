"""
Frontend Agent - Handles Next.js/React/TypeScript frontend development.
Generates pages, components, and configurations for the web frontend.
"""

from typing import Dict, Any, List, Optional
from agents.base_agent import BaseAgent, AgentType, Task, TaskStatus
from utils.project_layout import ProjectLayout, get_default_layout
from utils.template_renderer import get_renderer
import os
import logging


class FrontendAgent(BaseAgent):
    """Agent responsible for Next.js/React/TypeScript frontend development."""

    def __init__(self, agent_id: str = "frontend_main", workspace_path: str = ".", 
                 project_layout: Optional[ProjectLayout] = None,
                 project_id: Optional[str] = None,
                 tenant_id: Optional[int] = None,
                 orchestrator: Optional[Any] = None):
        # CRITICAL: Pass workspace_path to super() to ensure BaseAgent validates it
        super().__init__(
            agent_id, 
            AgentType.FRONTEND, 
            project_layout,
            workspace_path=workspace_path,
            project_id=project_id, 
            tenant_id=tenant_id, 
            orchestrator=orchestrator
        )
        self.frontend_files: List[str] = []
        self.template_renderer = get_renderer()

    def process_task(self, task: Task) -> Task:
        """
        Process a frontend task by generating Next.js/React code.
        
        Args:
            task: The frontend task to process
            
        Returns:
            The updated task
        """
        try:
            self.logger.info(f"Processing frontend task: {task.title}")
            
            # Extract task information
            description = task.description.lower()
            metadata = task.metadata
            
            # Generate frontend code
            files_created = []
            
            if "page" in description or "route" in description:
                files_created.extend(self._create_pages(task))
            
            if "component" in description:
                files_created.extend(self._create_components(task))
            
            if "auth" in description or "nextauth" in description:
                files_created.extend(self._create_auth_config(task))
            
            if "theme" in description or "toggle" in description:
                files_created.extend(self._create_theme(task))
            
            if "onboarding" in description:
                files_created.extend(self._create_onboarding(task))
            
            if "mapping" in description:
                files_created.extend(self._create_mappings_ui(task))
            
            # Update task metadata
            task.metadata["frontend_files"] = files_created
            task.result = {
                "files_created": files_created,
                "status": "completed"
            }

            self.complete_task(task.id, task.result)
            self.logger.info(f"Completed frontend task {task.id}")
            
        except Exception as e:
            error_msg = f"Error processing frontend task: {str(e)}"
            self.logger.error(error_msg, exc_info=True)
            self.fail_task(task.id, error_msg)
            
        return task

    def _create_pages(self, task: Task) -> List[str]:
        """Create Next.js pages."""
        files_created = []
        description = task.description.lower()
        
        if "onboarding" in description:
            files_created.append(self._create_onboarding_page(task))
        
        if "mapping" in description:
            files_created.append(self._create_mappings_page(task))
        
        if "job" in description or "jobs" in description:
            files_created.append(self._create_jobs_page(task))
        
        if "error" in description or "errors" in description:
            files_created.append(self._create_errors_page(task))
        
        return files_created

    def _create_onboarding_page(self, task: Task) -> str:
        """Create onboarding wizard page."""
        file_path = os.path.join(self.project_layout.web_pages_dir, "onboarding.tsx")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("frontend_agent/onboarding_page.tsx.j2"):
            content = self.template_renderer.render("frontend_agent/onboarding_page.tsx.j2", {})
        else:
            # Fallback inline template
            content = '''/**
 * Onboarding Wizard Page
 * Generated by FrontendAgent
 */

import { useState } from "react";
import { NextPage } from "next";
import axios from "axios";

const OnboardingPage: NextPage = () => {
  const [step, setStep] = useState(1);
  const [qboConnected, setQboConnected] = useState(false);
  const [odooUrl, setOdooUrl] = useState("");
  const [odooApiKey, setOdooApiKey] = useState("");
  const [odooDatabase, setOdooDatabase] = useState("");
  const [odooConnected, setOdooConnected] = useState(false);
  const [testing, setTesting] = useState(false);
  const [error, setError] = useState("");

  const testQBO = async () => {
    try {
      setTesting(true);
      const response = await axios.get("/api/connect/qbo/test");
      if (response.data.status === "success") {
        setQboConnected(true);
        setStep(2);
      }
    } catch (err: any) {
      setError(err.response?.data?.error || "Failed to connect to QuickBooks");
    } finally {
      setTesting(false);
    }
  };

  const saveOdoo = async () => {
    try {
      setTesting(true);
      const response = await axios.post("/api/connect/odoo/save", {
        url: odooUrl,
        api_key: odooApiKey,
        database: odooDatabase,
      });
      if (response.data.status === "success") {
        setOdooConnected(true);
      }
    } catch (err: any) {
      setError(err.response?.data?.error || "Failed to save Odoo connection");
    } finally {
      setTesting(false);
    }
  };

  const testOdoo = async () => {
    try {
      setTesting(true);
      const response = await axios.post("/api/connect/odoo/test", {
        url: odooUrl,
        api_key: odooApiKey,
        database: odooDatabase,
      });
      if (response.data.status === "success") {
        setOdooConnected(true);
        setStep(3);
      }
    } catch (err: any) {
      setError(err.response?.data?.error || "Failed to test Odoo connection");
    } finally {
      setTesting(false);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Welcome to Quick2Odoo</h1>
      
      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}

      <div className="max-w-2xl mx-auto">
        {/* Step 1: QuickBooks Connection */}
        {step === 1 && (
          <div className="bg-white shadow-md rounded-lg p-6">
            <h2 className="text-2xl font-semibold mb-4">Step 1: Connect QuickBooks</h2>
            <p className="text-gray-600 mb-4">
              Connect your QuickBooks Online account to get started.
            </p>
            <button
              onClick={testQBO}
              disabled={testing}
              className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50"
            >
              {testing ? "Connecting..." : "Connect QuickBooks"}
            </button>
            {qboConnected && (
              <div className="mt-4 text-green-600">
                [OK] QuickBooks connected successfully
              </div>
            )}
          </div>
        )}

        {/* Step 2: Save Odoo Connection */}
        {step === 2 && (
          <div className="bg-white shadow-md rounded-lg p-6">
            <h2 className="text-2xl font-semibold mb-4">Step 2: Connect Odoo</h2>
            <p className="text-gray-600 mb-4">
              Enter your Odoo v18 connection details.
            </p>
            
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Odoo URL
                </label>
                <input
                  type="text"
                  value={odooUrl}
                  onChange={(e) => setOdooUrl(e.target.value)}
                  placeholder="https://your-odoo-instance.com"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Database
                </label>
                <input
                  type="text"
                  value={odooDatabase}
                  onChange={(e) => setOdooDatabase(e.target.value)}
                  placeholder="database_name"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  API Key
                </label>
                <input
                  type="password"
                  value={odooApiKey}
                  onChange={(e) => setOdooApiKey(e.target.value)}
                  placeholder="your-api-key"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md"
                />
              </div>
            </div>

            <div className="mt-6 flex gap-4">
              <button
                onClick={saveOdoo}
                disabled={testing || !odooUrl || !odooDatabase || !odooApiKey}
                className="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50"
              >
                {testing ? "Saving..." : "Save Connection"}
              </button>
              
              <button
                onClick={testOdoo}
                disabled={testing || !odooUrl || !odooDatabase || !odooApiKey}
                className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50"
              >
                {testing ? "Testing..." : "Test Connection"}
              </button>
            </div>

            {odooConnected && (
              <div className="mt-4 text-green-600">
                [OK] Odoo connected successfully
              </div>
            )}
          </div>
        )}

        {/* Step 3: Completion */}
        {step === 3 && (
          <div className="bg-white shadow-md rounded-lg p-6">
            <h2 className="text-2xl font-semibold mb-4">Setup Complete!</h2>
            <p className="text-gray-600 mb-4">
              Your QuickBooks and Odoo connections are configured. You can now start syncing data.
            </p>
            <a
              href="/mappings"
              className="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded inline-block"
            >
              Go to Mappings
            </a>
          </div>
        )}
      </div>
    </div>
  );
};

export default OnboardingPage;
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.frontend_files.append(file_path)
        return file_path

    def _create_mappings_page(self, task: Task) -> str:
        """Create mappings UI page."""
        file_path = os.path.join(self.project_layout.web_pages_dir, "mappings.tsx")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("frontend_agent/mappings_page.tsx.j2"):
            content = self.template_renderer.render("frontend_agent/mappings_page.tsx.j2", {})
        else:
            # Fallback inline template
            content = '''/**
 * Mappings Page - Rich Mapping UI with Live Search
 * Generated by FrontendAgent
 */

import { useState, useEffect } from "react";
import { NextPage } from "next";
import axios from "axios";

interface Mapping {
  id: string;
  qbo_entity: string;
  qbo_name: string;
  odoo_entity: string;
  odoo_id: number;
  odoo_name: string;
}

const MappingsPage: NextPage = () => {
  const [mappings, setMappings] = useState<Mapping[]>([]);
  const [qboSearch, setQboSearch] = useState("");
  const [odooSearch, setOdooSearch] = useState("");
  const [qboResults, setQboResults] = useState<any[]>([]);
  const [odooResults, setOdooResults] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedQbo, setSelectedQbo] = useState<any>(null);
  const [selectedOdoo, setSelectedOdoo] = useState<any>(null);

  useEffect(() => {
    loadMappings();
  }, []);

  const loadMappings = async () => {
    try {
      const response = await axios.get("/api/mappings");
      setMappings(response.data.mappings || []);
    } catch (err) {
      console.error("Failed to load mappings:", err);
    }
  };

  const searchQBO = async (query: string) => {
    if (!query || query.length < 2) {
      setQboResults([]);
      return;
    }

    try {
      setLoading(true);
      const response = await axios.get(`/api/search/qbo?q=${encodeURIComponent(query)}`);
      setQboResults(response.data.results || []);
    } catch (err) {
      console.error("QBO search failed:", err);
    } finally {
      setLoading(false);
    }
  };

  const searchOdoo = async (query: string) => {
    if (!query || query.length < 2) {
      setOdooResults([]);
      return;
    }

    try {
      setLoading(true);
      const response = await axios.get(`/api/search/odoo?q=${encodeURIComponent(query)}`);
      setOdooResults(response.data.results || []);
    } catch (err) {
      console.error("Odoo search failed:", err);
    } finally {
      setLoading(false);
    }
  };

  const saveMapping = async () => {
    if (!selectedQbo || !selectedOdoo) return;

    try {
      setLoading(true);
      await axios.post("/api/mappings", {
        qbo_entity: selectedQbo.type,
        qbo_id: selectedQbo.id,
        qbo_name: selectedQbo.name,
        odoo_entity: selectedOdoo.model,
        odoo_id: selectedOdoo.id,
        odoo_name: selectedOdoo.name,
      });
      
      await loadMappings();
      setSelectedQbo(null);
      setSelectedOdoo(null);
      setQboSearch("");
      setOdooSearch("");
    } catch (err) {
      console.error("Failed to save mapping:", err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Entity Mappings</h1>

      <div className="grid grid-cols-2 gap-6 mb-8">
        {/* QuickBooks Search */}
        <div className="bg-white shadow-md rounded-lg p-6">
          <h2 className="text-xl font-semibold mb-4">QuickBooks</h2>
          <input
            type="text"
            value={qboSearch}
            onChange={(e) => {
              setQboSearch(e.target.value);
              searchQBO(e.target.value);
            }}
            placeholder="Search QuickBooks entities..."
            className="w-full px-3 py-2 border border-gray-300 rounded-md mb-4"
          />
          
          {qboResults.length > 0 && (
            <div className="space-y-2 max-h-64 overflow-y-auto">
              {qboResults.map((result) => (
                <div
                  key={result.id}
                  onClick={() => setSelectedQbo(result)}
                  className={`p-2 border rounded cursor-pointer ${
                    selectedQbo?.id === result.id ? "bg-blue-100 border-blue-500" : ""
                  }`}
                >
                  <div className="font-semibold">{result.name}</div>
                  <div className="text-sm text-gray-500">{result.type}</div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Odoo Search */}
        <div className="bg-white shadow-md rounded-lg p-6">
          <h2 className="text-xl font-semibold mb-4">Odoo</h2>
          <input
            type="text"
            value={odooSearch}
            onChange={(e) => {
              setOdooSearch(e.target.value);
              searchOdoo(e.target.value);
            }}
            placeholder="Search Odoo entities..."
            className="w-full px-3 py-2 border border-gray-300 rounded-md mb-4"
          />
          
          {odooResults.length > 0 && (
            <div className="space-y-2 max-h-64 overflow-y-auto">
              {odooResults.map((result) => (
                <div
                  key={result.id}
                  onClick={() => setSelectedOdoo(result)}
                  className={`p-2 border rounded cursor-pointer ${
                    selectedOdoo?.id === result.id ? "bg-blue-100 border-blue-500" : ""
                  }`}
                >
                  <div className="font-semibold">{result.name}</div>
                  <div className="text-sm text-gray-500">{result.model}</div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Save Mapping Button */}
      {selectedQbo && selectedOdoo && (
        <div className="text-center mb-8">
          <button
            onClick={saveMapping}
            disabled={loading}
            className="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-6 rounded disabled:opacity-50"
          >
            {loading ? "Saving..." : "Save Mapping"}
          </button>
          <p className="mt-2 text-sm text-gray-600">
            Map: {selectedQbo.name} â†’ {selectedOdoo.name}
          </p>
        </div>
      )}

      {/* Existing Mappings */}
      <div className="bg-white shadow-md rounded-lg p-6">
        <h2 className="text-xl font-semibold mb-4">Existing Mappings</h2>
        {mappings.length === 0 ? (
          <p className="text-gray-500">No mappings yet. Create one above.</p>
        ) : (
          <table className="w-full">
            <thead>
              <tr className="border-b">
                <th className="text-left p-2">QuickBooks</th>
                <th className="text-left p-2">Odoo</th>
                <th className="text-left p-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {mappings.map((mapping) => (
                <tr key={mapping.id} className="border-b">
                  <td className="p-2">{mapping.qbo_name}</td>
                  <td className="p-2">{mapping.odoo_name}</td>
                  <td className="p-2">
                    <button className="text-red-500 hover:text-red-700">Delete</button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </div>
    </div>
  );
};

export default MappingsPage;
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.frontend_files.append(file_path)
        return file_path

    def _create_jobs_page(self, task: Task) -> str:
        """Create jobs page with SSE."""
        file_path = os.path.join(self.project_layout.web_pages_dir, "jobs.tsx")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("frontend_agent/jobs_page.tsx.j2"):
            content = self.template_renderer.render("frontend_agent/jobs_page.tsx.j2", {})
        else:
            # Fallback inline template
            content = '''/**
 * Jobs Page with Server-Sent Events
 * Generated by FrontendAgent
 */

import { useState, useEffect } from "react";
import { NextPage } from "next";
import axios from "axios";

interface Job {
  id: string;
  type: string;
  status: string;
  progress: number;
  created_at: string;
}

const JobsPage: NextPage = () => {
  const [jobs, setJobs] = useState<Job[]>([]);
  const [eventSource, setEventSource] = useState<EventSource | null>(null);

  useEffect(() => {
    loadJobs();
    connectSSE();
    
    return () => {
      if (eventSource) {
        eventSource.close();
      }
    };
  }, []);

  const loadJobs = async () => {
    try {
      const response = await axios.get("/api/ops/jobs");
      setJobs(response.data.jobs || []);
    } catch (err) {
      console.error("Failed to load jobs:", err);
    }
  };

  const connectSSE = async () => {
    try {
      // Get SSE token
      const tokenResponse = await axios.get("/api/sse/token");
      const token = tokenResponse.data.token;

      const es = new EventSource(`/api/ops/stream?token=${token}`);
      
      es.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === "job_update") {
          setJobs((prev) => {
            const index = prev.findIndex((j) => j.id === data.job.id);
            if (index >= 0) {
              const updated = [...prev];
              updated[index] = data.job;
              return updated;
            }
            return [...prev, data.job];
          });
        }
      };

      es.onerror = () => {
        console.error("SSE connection error");
        setTimeout(connectSSE, 5000); // Reconnect after 5 seconds
      };

      setEventSource(es);
    } catch (err) {
      console.error("Failed to connect SSE:", err);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Jobs</h1>

      <div className="bg-white shadow-md rounded-lg p-6">
        {jobs.length === 0 ? (
          <p className="text-gray-500">No jobs yet.</p>
        ) : (
          <div className="space-y-4">
            {jobs.map((job) => (
              <div key={job.id} className="border rounded p-4">
                <div className="flex justify-between items-center mb-2">
                  <div>
                    <span className="font-semibold">{job.type}</span>
                    <span className={`ml-4 px-2 py-1 rounded text-sm ${
                      job.status === "completed" ? "bg-green-100 text-green-800" :
                      job.status === "failed" ? "bg-red-100 text-red-800" :
                      "bg-blue-100 text-blue-800"
                    }`}>
                      {job.status}
                    </span>
                  </div>
                  <div className="text-sm text-gray-500">{job.created_at}</div>
                </div>
                {job.status === "in_progress" && (
                  <div className="w-full bg-gray-200 rounded-full h-2.5">
                    <div
                      className="bg-blue-600 h-2.5 rounded-full"
                      style={{ width: `${job.progress}%` }}
                    />
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default JobsPage;
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.frontend_files.append(file_path)
        return file_path

    def _create_errors_page(self, task: Task) -> str:
        """Create errors page with SSE."""
        file_path = os.path.join(self.project_layout.web_pages_dir, "errors.tsx")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("frontend_agent/errors_page.tsx.j2"):
            content = self.template_renderer.render("frontend_agent/errors_page.tsx.j2", {})
        else:
            # Fallback inline template
            content = '''/**
 * Errors Page with Server-Sent Events
 * Generated by FrontendAgent
 */

import { useState, useEffect } from "react";
import { NextPage } from "next";
import axios from "axios";

interface Error {
  id: string;
  message: string;
  type: string;
  created_at: string;
}

const ErrorsPage: NextPage = () => {
  const [errors, setErrors] = useState<Error[]>([]);
  const [eventSource, setEventSource] = useState<EventSource | null>(null);

  useEffect(() => {
    loadErrors();
    connectSSE();
    
    return () => {
      if (eventSource) {
        eventSource.close();
      }
    };
  }, []);

  const loadErrors = async () => {
    try {
      const response = await axios.get("/api/ops/errors");
      setErrors(response.data.errors || []);
    } catch (err) {
      console.error("Failed to load errors:", err);
    }
  };

  const connectSSE = async () => {
    try {
      const tokenResponse = await axios.get("/api/sse/token");
      const token = tokenResponse.data.token;

      const es = new EventSource(`/api/ops/stream?token=${token}`);
      
      es.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === "error") {
          setErrors((prev) => [data.error, ...prev]);
        }
      };

      es.onerror = () => {
        setTimeout(connectSSE, 5000);
      };

      setEventSource(es);
    } catch (err) {
      console.error("Failed to connect SSE:", err);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Errors</h1>

      <div className="bg-white shadow-md rounded-lg p-6">
        {errors.length === 0 ? (
          <p className="text-gray-500">No errors.</p>
        ) : (
          <div className="space-y-4">
            {errors.map((error) => (
              <div key={error.id} className="border border-red-300 rounded p-4 bg-red-50">
                <div className="flex justify-between items-start mb-2">
                  <div>
                    <span className="font-semibold text-red-800">{error.type}</span>
                    <p className="text-red-600 mt-1">{error.message}</p>
                  </div>
                  <div className="text-sm text-gray-500">{error.created_at}</div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default ErrorsPage;
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.frontend_files.append(file_path)
        return file_path

    def _create_components(self, task: Task) -> List[str]:
        """Create React components."""
        files_created = []
        description = task.description.lower()
        
        if "theme" in description or "toggle" in description:
            files_created.append(self._create_theme_toggle(task))
        
        return files_created

    def _create_theme_toggle(self, task: Task) -> str:
        """Create theme toggle component."""
        file_path = os.path.join(self.project_layout.web_components_dir, "ThemeToggle.tsx")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("frontend_agent/theme_toggle.tsx.j2"):
            content = self.template_renderer.render("frontend_agent/theme_toggle.tsx.j2", {})
        else:
            # Fallback inline template
            content = '''/**
 * Theme Toggle Component
 * Generated by FrontendAgent
 */

import { useEffect, useState } from "react";

const ThemeToggle: React.FC = () => {
  const [theme, setTheme] = useState<"light" | "dark">("light");

  useEffect(() => {
    // Load theme from localStorage
    const savedTheme = localStorage.getItem("theme") as "light" | "dark" | null;
    if (savedTheme) {
      setTheme(savedTheme);
      document.documentElement.classList.toggle("dark", savedTheme === "dark");
    }
  }, []);

  const toggleTheme = () => {
    const newTheme = theme === "light" ? "dark" : "light";
    setTheme(newTheme);
    localStorage.setItem("theme", newTheme);
    document.documentElement.classList.toggle("dark", newTheme === "dark");
  };

  return (
    <button
      onClick={toggleTheme}
      className="p-2 rounded-md bg-gray-200 dark:bg-gray-800 text-gray-800 dark:text-gray-200"
      aria-label="Toggle theme"
    >
      {theme === "light" ? "[DARK]" : "[LIGHT]"}
    </button>
  );
};

export default ThemeToggle;
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.frontend_files.append(file_path)
        return file_path

    def _create_auth_config(self, task: Task) -> List[str]:
        """Create NextAuth configuration."""
        files_created = []
        
        files_created.append(self._create_nextauth_config(task))
        
        return files_created

    def _create_nextauth_config(self, task: Task) -> str:
        """Create NextAuth API route."""
        file_path = os.path.join(self.project_layout.web_api_dir, "auth/[...nextauth].ts")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("frontend_agent/nextauth_config.ts.j2"):
            content = self.template_renderer.render("frontend_agent/nextauth_config.ts.j2", {})
        else:
            # Fallback inline template
            content = '''/**
 * NextAuth API Route
 * Generated by FrontendAgent
 */

import NextAuth, { NextAuthOptions } from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import OktaProvider from "next-auth/providers/okta";
import AzureADProvider from "next-auth/providers/azure-ad";

export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_ID!,
      clientSecret: process.env.GOOGLE_SECRET!,
    }),
    OktaProvider({
      clientId: process.env.OKTA_ID!,
      clientSecret: process.env.OKTA_SECRET!,
      issuer: process.env.OKTA_ISSUER!,
    }),
    AzureADProvider({
      clientId: process.env.AZURE_AD_CLIENT_ID!,
      clientSecret: process.env.AZURE_AD_CLIENT_SECRET!,
      tenantId: process.env.AZURE_AD_TENANT_ID!,
    }),
  ],
  secret: process.env.NEXTAUTH_SECRET,
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        token.accessToken = account.access_token;
      }
      return token;
    },
    async session({ session, token }) {
      session.accessToken = token.accessToken;
      return session;
    },
  },
};

export default NextAuth(authOptions);
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.frontend_files.append(file_path)
        return file_path

    def _create_theme(self, task: Task) -> List[str]:
        """Create theme configuration."""
        # Theme toggle component is already created in _create_components
        return []

    def _create_onboarding(self, task: Task) -> List[str]:
        """Create onboarding related files."""
        # Onboarding page is already created in _create_pages
        return []

    def _create_mappings_ui(self, task: Task) -> List[str]:
        """Create mappings UI files."""
        # Mappings page is already created in _create_pages
        return []

