"""
Workflow Agent - Handles Temporal workflow orchestration.
Generates workflow definitions, activities, and worker code.
"""

from typing import Dict, Any, List, Optional
from agents.base_agent import BaseAgent, AgentType, Task, TaskStatus
from utils.project_layout import ProjectLayout, get_default_layout
from utils.template_renderer import get_renderer
import os
import logging


class WorkflowAgent(BaseAgent):
    """Agent responsible for Temporal workflow orchestration."""

    def __init__(self, agent_id: str = "workflow_main", workspace_path: str = ".", 
                 project_layout: Optional[ProjectLayout] = None,
                 project_id: Optional[str] = None,
                 tenant_id: Optional[int] = None):
        super().__init__(agent_id, AgentType.WORKFLOW, project_layout,
                        project_id=project_id, tenant_id=tenant_id)
        self.workspace_path = workspace_path
        self.workflow_files: List[str] = []
        self.template_renderer = get_renderer()

    def process_task(self, task: Task) -> Task:
        """
        Process a workflow task by generating Temporal workflow code.
        
        Args:
            task: The workflow task to process
            
        Returns:
            The updated task
        """
        try:
            self.logger.info(f"Processing workflow task: {task.title}")
            
            description = task.description.lower()
            files_created = []
            
            if "workflow" in description or "temporal" in description:
                files_created.extend(self._create_workflows(task))
            
            if "activity" in description or "activities" in description:
                files_created.extend(self._create_activities(task))
            
            if "worker" in description:
                files_created.extend(self._create_worker(task))
            
            task.metadata["workflow_files"] = files_created
            task.result = {"files_created": files_created, "status": "completed"}
            self.complete_task(task.id, task.result)
            self.logger.info(f"Completed workflow task {task.id}")
            
        except Exception as e:
            error_msg = f"Error processing workflow task: {str(e)}"
            self.logger.error(error_msg, exc_info=True)
            self.fail_task(task.id, error_msg)
            
        return task

    def _create_workflows(self, task: Task) -> List[str]:
        """Create Temporal workflow definitions."""
        files_created = []
        description = task.description.lower()
        
        if "backfill" in description:
            files_created.append(self._create_backfill_workflow(task))
        
        return files_created

    def _create_backfill_workflow(self, task: Task) -> str:
        """Create backfill workflow."""
        file_path = os.path.join(self.project_layout.workflows_dir, "backfill.py")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("workflow_agent/backfill_workflow.py.j2"):
            content = self.template_renderer.render("workflow_agent/backfill_workflow.py.j2", {})
        else:
            # Fallback inline template
            content = '''"""
Temporal Backfill Workflow
Generated by WorkflowAgent
"""

from temporalio import workflow
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)


@workflow.defn
class BackfillWorkflow:
    """
    Workflow for syncing entities from source accounting platform to Odoo
    Supports: QuickBooks, SAGE, Wave, Expensify, and more
    """
    
    @workflow.run
    async def run(self, tenant_id: str, entity_types: List[str]) -> Dict[str, Any]:
        """
        Run backfill workflow.
        
        Args:
            tenant_id: Tenant ID
            entity_types: List of entity types to sync
            
        Returns:
            Workflow result
        """
        logger.info(f"Starting backfill workflow for tenant {tenant_id}")
        
        results = {}
        
        for entity_type in entity_types:
            try:
                # Fetch entities from QuickBooks
                qbo_entities = await workflow.execute_activity(
                    fetch_qbo_entities,
                    args=[tenant_id, entity_type],
                    start_to_close_timeout=300,
                )
                
                # Upsert to Odoo
                result = await workflow.execute_activity(
                    upsert_odoo_entities,
                    args=[tenant_id, entity_type, qbo_entities],
                    start_to_close_timeout=600,
                )
                
                results[entity_type] = {
                    "status": "success",
                    "count": len(qbo_entities),
                    "result": result
                }
                
            except Exception as e:
                logger.error(f"Error syncing {entity_type}: {str(e)}")
                results[entity_type] = {
                    "status": "failed",
                    "error": str(e)
                }
        
        return {
            "tenant_id": tenant_id,
            "results": results
        }


# Import activity functions (defined in activities)
from ..activities.entities import fetch_qbo_entities, upsert_odoo_entities
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.workflow_files.append(file_path)
        return file_path

    def _create_activities(self, task: Task) -> List[str]:
        """Create Temporal activity implementations."""
        files_created = []
        description = task.description.lower()
        
        if "entity" in description or "backfill" in description:
            files_created.append(self._create_entity_activities(task))
        
        return files_created

    def _create_entity_activities(self, task: Task) -> str:
        """Create entity sync activities."""
        file_path = os.path.join(self.project_layout.worker_activities_dir, "entities.py")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("workflow_agent/entity_activities.py.j2"):
            content = self.template_renderer.render("workflow_agent/entity_activities.py.j2", {})
        else:
            # Fallback inline template
            content = '''"""
Temporal Activities for Entity Sync
Generated by WorkflowAgent
"""

from temporalio import activity
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)


@activity.defn
async def fetch_qbo_entities(tenant_id: str, entity_type: str) -> List[Dict]:
    """
    Fetch entities from QuickBooks Online.
    
    Args:
        tenant_id: Tenant ID
        entity_type: Entity type (Customer, Invoice, etc.)
        
    Returns:
        List of QBO entities
    """
    logger.info(f"Fetching {entity_type} from QBO for tenant {tenant_id}")
    
    # Import QBO client
    from app.clients.qbo import QBOClient
    
    # Get tenant's QBO tokens
    # tenant = get_tenant(tenant_id)
    # qbo_client = QBOClient(tenant.qbo_realm_id, tenant.qbo_access_token)
    
    # Query entities based on type
    # if entity_type == "Customer":
    #     entities = qbo_client.get_customers()
    # elif entity_type == "Invoice":
    #     entities = qbo_client.get_invoices()
    # ...
    
    # Placeholder
    return []


@activity.defn
async def upsert_odoo_entities(tenant_id: str, entity_type: str, qbo_entities: List[Dict]) -> Dict[str, Any]:
    """
    Upsert entities to Odoo.
    
    Args:
        tenant_id: Tenant ID
        entity_type: Entity type
        qbo_entities: List of QBO entities
        
    Returns:
        Upsert result
    """
    logger.info(f"Upserting {len(qbo_entities)} {entity_type} to Odoo for tenant {tenant_id}")
    
    # Import Odoo client
    from app.clients.odoo import OdooClient
    
    # Get tenant's Odoo connection
    # tenant = get_tenant(tenant_id)
    # odoo_client = OdooClient(
    #     tenant.odoo_url,
    #     tenant.odoo_database,
    #     tenant.odoo_username,
    #     tenant.odoo_api_key
    # )
    
    # Transform and upsert entities
    upserted = 0
    errors = []
    id_map = {}
    
    for qbo_entity in qbo_entities:
        try:
            # Transform QBO entity to Odoo format
            # odoo_data = transform_entity(qbo_entity, entity_type)
            
            # Check if mapping exists
            # mapping = get_mapping(tenant_id, entity_type, qbo_entity["Id"])
            
            # Upsert to Odoo
            # if mapping:
            #     odoo_id = odoo_client.write(mapping.odoo_model, mapping.odoo_id, odoo_data)
            # else:
            #     odoo_id = odoo_client.create(mapping.odoo_model, odoo_data)
            
            # Save ID mapping
            # save_id_mapping(tenant_id, qbo_entity["Id"], odoo_id)
            
            upserted += 1
        except Exception as e:
            logger.error(f"Error upserting entity: {str(e)}")
            errors.append({"entity": qbo_entity, "error": str(e)})
            # Log error
            # log_error(tenant_id, entity_type, str(e))
    
    return {
        "upserted": upserted,
        "errors": len(errors),
        "error_details": errors
    }
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.workflow_files.append(file_path)
        return file_path

    def _create_worker(self, task: Task) -> List[str]:
        """Create Temporal worker code."""
        files_created = []
        
        files_created.append(self._create_worker_main(task))
        
        return files_created

    def _create_worker_main(self, task: Task) -> str:
        """Create worker main file."""
        file_path = os.path.join(self.project_layout.worker_dir, "run_worker.py")
        full_path = os.path.join(self.workspace_path, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Use template if available
        if self.template_renderer.template_exists("workflow_agent/worker_main.py.j2"):
            content = self.template_renderer.render("workflow_agent/worker_main.py.j2", {})
        else:
            # Fallback inline template
            content = '''"""
Temporal Worker Runner
Generated by WorkflowAgent
"""

import asyncio
import logging
import os
from temporalio.client import Client
from temporalio.worker import Worker

from shared.temporal_defs.workflows.backfill import BackfillWorkflow
from worker.temporal.activities.entities import fetch_qbo_entities, upsert_odoo_entities


logger = logging.getLogger(__name__)

TEMPORAL_ADDRESS = os.getenv("TEMPORAL_ADDRESS", "localhost:7233")
TEMPORAL_NAMESPACE = os.getenv("TEMPORAL_NAMESPACE", "default")
TEMPORAL_TASK_QUEUE = os.getenv("TEMPORAL_TASK_QUEUE", "q2o-sync")


async def main():
    """Main worker function."""
    logger.info(f"Connecting to Temporal at {TEMPORAL_ADDRESS}")
    
    # Connect to Temporal
    client = await Client.connect(
        TEMPORAL_ADDRESS,
        namespace=TEMPORAL_NAMESPACE,
    )
    
    logger.info(f"Starting worker on task queue: {TEMPORAL_TASK_QUEUE}")
    
    # Create worker
    worker = Worker(
        client,
        task_queue=TEMPORAL_TASK_QUEUE,
        workflows=[BackfillWorkflow],
        activities=[fetch_qbo_entities, upsert_odoo_entities],
    )
    
    logger.info("Worker started. Listening for tasks...")
    
    # Run worker
    await worker.run()


if __name__ == "__main__":
    asyncio.run(main())
'''
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        self.workflow_files.append(file_path)
        return file_path

