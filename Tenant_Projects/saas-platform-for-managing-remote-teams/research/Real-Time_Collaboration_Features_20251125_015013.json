{
  "query": "Real-Time Collaboration Features:",
  "timestamp": "2025-11-25T01:50:13.082241",
  "depth": "deep",
  "search_results": [],
  "key_findings": [
    "\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\",",
    "\"https://firebase.google.com/docs/database\",",
    "\"https://ably.com/docs/realtime\",",
    "\"https://pusher.com/docs/channels/\"",
    "\"description\": \"Basic WebSocket Server (using `websockets` library)\",",
    "\"code\": \"import asyncio\\nimport websockets\\n\\nCONNECTED_CLIENTS = set()\\n\\nasync def register(websocket):\\n    CONNECTED_CLIENTS.add(websocket)\\n    print(f\\\"Client connected: {websocket.remote_address}\\\")\\n\\nasync def unregister(websocket):\\n    CONNECTED_CLIENTS.remove(websocket)\\n    print(f\\\"Client disconnected: {websocket.remote_address}\\\")\\n\\nasync def broadcast(message):\\n    if CONNECTED_CLIENTS:\\n        await asyncio.wait([client.send(message) for client in CONNECTED_CLIENTS])\\n\\nasync def handler(websocket, path):\\n    await register(websocket)\\n    try:\\n        async for message in websocket:\\n            print(f\\\"Received from {websocket.remote_address}: {message}\\\")\\n            # In a real app, process message, update state, then broadcast\\n            await broadcast(f\\\"Echo from server: {message}\\\")\\n    except websockets.exceptions.ConnectionClosedOK:\\n        pass\\n    finally:\\n        await unregister(websocket)\\n\\nasync def main():\\n    async with websockets.serve(handler, \\\"localhost\\\", 8765):\\n        await asyncio.Future()  # Run forever\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"WebSocket server started on ws://localhost:8765\\\")\\n    asyncio.run(main())\"",
    "\"description\": \"Basic WebSocket Client (Browser)\",",
    "\"code\": \"const socket = new WebSocket('ws://localhost:8765');\\n\\nsocket.onopen = (event) => {\\n    console.log('WebSocket connection opened:', event);\\n    socket.send('Hello from client!');\\n};\\n\\nsocket.onmessage = (event) => {\\n    console.log('Message from server:', event.data);\\n};\\n\\nsocket.onclose = (event) => {\\n    if (event.wasClean) {\\n        console.log(`Connection closed cleanly, code=${event.code}, reason=${event.reason}`);\\n    } else {\\n        console.error('Connection died');\\n    }\\n};\\n\\nsocket.onerror = (error) => {\\n    console.error('WebSocket error:', error);\\n};\\n\\n// Example of sending a message\\nfunction sendMessage() {\\n    const message = document.getElementById('messageInput').value;\\n    if (socket.readyState === WebSocket.OPEN) {\\n        socket.send(message);\\n        document.getElementById('messageInput').value = '';\\n    } else {\\n        console.warn('WebSocket is not open.');\\n    }\\n}\\n\\n// Add an input and button to an HTML page to test:\\n// <input type=\\\"text\\\" id=\\\"messageInput\\\" />\\n// <button onclick=\\\"sendMessage()\\\">Send</button>\"",
    "\"description\": \"Collaborative Text Editing with Yjs (CRDT)\",",
    "\"code\": \"import * as Y from 'yjs';\\nimport { WebsocketProvider } from 'y-websocket';\\n\\n// Create a Yjs document\\nconst ydoc = new Y.Doc();\\n\\n// Connect to a WebSocket provider (e.g., y-websocket server)\\n// You'd typically run a y-websocket server: `npx y-websocket`\\nconst provider = new WebsocketProvider(\\n  'ws://localhost:1234', // WebSocket server URL\\n  'my-roomname',        // Room name for collaboration\\n  ydoc\\n);\\n\\n// Get a shared text type\\nconst ytext = ydoc.getText('codemirror');\\n\\n// --- Example: Integrating with a simple textarea ---\\nconst textarea = document.createElement('textarea');\\ndocument.body.appendChild(textarea);\\n\\n// Update textarea when Yjs document changes\\nytext.observe(event => {\\n  if (textarea.value !== ytext.toString()) {\\n    textarea.value = ytext.toString();\\n  }\\n});\\n\\n// Update Yjs document when textarea changes\\ntextarea.addEventListener('input', () => {\\n  // This is a simplified approach. For robust integration with rich editors\\n  // (like CodeMirror, Monaco), you'd use specific Yjs bindings.\\n  const currentText = ytext.toString();\\n  const newText = textarea.value;\\n\\n  if (newText.length < currentText.length) {\\n    // Deletion\\n    const start = findFirstDifferenceIndex(currentText, newText);\\n    const end = findFirstDifferenceIndex(currentText.split('').reverse().join(''), newText.split('').reverse().join(''));\\n    ytext.delete(start, currentText.length - newText.length);\\n  } else if (newText.length > currentText.length) {\\n    // Insertion\\n    const start = findFirstDifferenceIndex(currentText, newText);\\n    ytext.insert(start, newText.substring(start, start + (newText.length - currentText.length)));\\n  } else if (newText !== currentText) {\\n    // Replacement (more complex, often handled by delete then insert)\\n    ytext.delete(0, currentText.length);\\n    ytext.insert(0, newText);\\n  }\\n});\\n\\n// Helper to find the first differing character index\\nfunction findFirstDifferenceIndex(str1, str2) {\\n  let i = 0;\\n  while (i < str1.length && i < str2.length && str1[i] === str2[i]) {\\n    i++;\\n  }\\n  return i;\\n}\\n\\n// Initial content (optional)\\nydoc.transact(() => {\\n  ytext.insert(0, 'Start typing here collaboratively!');\\n});\\n\\n// You can also get other shared types like Maps, Arrays, etc.\\nconst ymap = ydoc.getMap('metadata');\\nymap.set('title', 'My Collaborative Document');\\n\\nymap.observe(event => {\\n  console.log('Metadata changed:', ymap.toJSON());\\n});\\n\\n// To disconnect:\\n// provider.disconnect();\""
  ],
  "documentation_urls": [
    "https://ably.com/docs/realtime\",",
    "https://firebase.google.com/docs/database\",",
    "https://automerge.org/docs/\",",
    "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\",",
    "https://socket.io/docs/\",",
    "https://pusher.com/docs/channels/\"",
    "https://docs.yjs.dev/\","
  ],
  "code_examples": [],
  "best_practices": [],
  "confidence_score": 45,
  "sources_consulted": [
    "llm_research_text",
    "llm_research"
  ],
  "cached": false
}