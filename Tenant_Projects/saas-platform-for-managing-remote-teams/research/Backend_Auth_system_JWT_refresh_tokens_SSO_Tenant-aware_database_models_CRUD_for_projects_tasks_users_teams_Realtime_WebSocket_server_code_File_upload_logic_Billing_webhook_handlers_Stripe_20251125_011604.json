{
  "query": "Backend: Auth system (JWT, refresh tokens, SSO). Tenant-aware database models. CRUD for projects, tasks, users, teams. Realtime WebSocket server code. File upload logic. Billing webhook handlers (Stripe).",
  "timestamp": "2025-11-25T01:16:04.252283",
  "depth": "adaptive",
  "search_results": [],
  "key_findings": [
    "\"**Multi-tenancy is Foundational:** Implementing tenant-aware database models correctly is paramount. It impacts every data access layer and requires careful design to prevent data leakage and ensure scalability. Row-level security (adding `tenant_id` to tables) is a common and flexible approach.\",",
    "\"**Robust Authentication is Non-Negotiable:** A combination of JWTs for short-lived access tokens and refresh tokens for long-lived sessions provides a secure and stateless authentication mechanism. SSO integration via OAuth 2.0/OpenID Connect is crucial for enterprise adoption.\",",
    "\"**Asynchronous Processing for Scalability:** Realtime WebSockets, file uploads, and billing webhook handlers are prime candidates for asynchronous processing. This prevents blocking the main application thread, improves responsiveness, and allows for better scaling.\",",
    "\"**Security by Design Across All Layers:** From validating JWT signatures and verifying Stripe webhook events to sanitizing file uploads and enforcing tenant context, security must be baked into every component. Input validation, output encoding, and least privilege are critical.\",",
    "\"**Leverage Established Libraries and Services:** Do not reinvent the wheel for core functionalities like JWT handling (`PyJWT`), cloud storage (`boto3` for S3), or payment processing (`stripe-python`). These libraries are battle-tested and handle many complexities.\",",
    "\"**Idempotency and Error Handling for External Integrations:** Webhook handlers (e.g., Stripe) must be idempotent to safely process duplicate events. Comprehensive logging, monitoring, and robust error handling are essential for debugging and maintaining external integrations.\",",
    "\"**Realtime Requires a Scalable Backend:** For WebSockets, consider a message broker (like Redis Pub/Sub or RabbitMQ) to facilitate communication between multiple WebSocket server instances, enabling horizontal scaling and decoupling message producers from consumers.\",",
    "\"**Performance Optimization is Continuous:** Database indexing (especially on `tenant_id`), caching strategies, efficient ORM queries, and optimized file storage/retrieval are crucial for maintaining performance as the system scales.\",",
    "\"**API Design for CRUD Operations:** Standard RESTful principles (GET, POST, PUT, DELETE) with proper resource naming, pagination, filtering, and sorting capabilities will make the API intuitive and efficient for clients.\",",
    "\"**Secure File Handling:** Implement strict validation for file types and sizes. Store files in secure, object-storage solutions (like AWS S3) and use pre-signed URLs for temporary, controlled access, rather than serving directly from the application server.\""
  ],
  "documentation_urls": [
    "https://pyjwt.readthedocs.io/en/stable/\",",
    "https://stripe.com/docs/webhooks\",",
    "https://fastapi.tiangolo.com/advanced/websockets/\",",
    "https://oauth.net/2/\",",
    "https://channels.readthedocs.io/en/stable/\",",
    "https://openid.net/connect/\",",
    "https://stripe.com/docs/api/python\",",
    "https://www.postgresql.org/docs/current/ddl-schemas.html\",",
    "https://boto3.amazonaws.com/v1/documentation/api/latest/index.html\",",
    "https://docs.sqlalchemy.org/en/20/orm/session_basics.html\""
  ],
  "code_examples": [],
  "best_practices": [],
  "confidence_score": 45,
  "sources_consulted": [
    "llm_research_text",
    "llm_research"
  ],
  "cached": false
}